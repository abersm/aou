# Pie chart ---------------------------------------------------------------

#' Pie chart
#'
#' @param df Data frame
#' @param categorical_var Variable in `df` containing categories. Enter as quoted column name
#' @param count_var Variable in `df` containing counts (or proportions or percentages) for each `categorical_var`. Enter as quoted column name. Default is `"n"`
#' @param order_by Variable in `df` to order unique values in `df[[categorical_var]]`. Enter as quoted column column name. Default is `count_var`. If `NULL`, values appear in piechart in same order as row order in `df`. In this case, `rev_order` is ignored.
#' @param rev_order If `TRUE`, order of levels in pie chart are reversed so that levels are plotted from most to least frequent. Default is `FALSE` (levels are plotted from least frequent to most frequent)
#' @param fill_colors Pie colors for each unique value in `df[[categorical_var]]`
#' @param border_color Line color for pie borders. Default is black
#' @param show_legend If `TRUE` (default), legend is displayed
#' @param legend_title Legend title. Default is blank
#' @returns ggplot object
#' @export
plot_piechart <- function(
    df,
    categorical_var,
    count_var = "n",
    rev_order = FALSE,
    order_by = count_var,
    fill_colors = c("#333333", "#00A1D5", "#E41A1C", "#6761A8", "#009872", "#EFC000", "#045A8D", "#FF7F00", "#BABABA", "#FFFFFF"),
    colors = fill_colors,
    border_color = "#000000",
    show_legend = TRUE,
    legend_title = "") {
  pkg_required("ggforce")
  plot_fn <- "plot_piechart"
  categorical_var <- get_input(categorical_var)
  count_var <- get_input(count_var)
  order_by <- get_input(order_by)
  df <- remove_na(df, c(categorical_var, count_var))
  if (!is.null(order_by)) {
    df <- df[order(.subset2(df, order_by), decreasing = rev_order), , drop = FALSE]
  }
  colors <- rep(colors, length.out = length(unique(.subset2(df, categorical_var))))
  p <- ggplot2::ggplot(df) +
    ggforce::geom_arc_bar(
      mapping = ggplot2::aes(
        x0 = 0,
        y0 = 0,
        r0 = 0,
        r = 1,
        amount = .data[[count_var]],
        fill = .data[[categorical_var]]
      ),
      stat = "pie",
      color = border_color,
      show.legend = show_legend
    ) +
    ggplot2::scale_fill_manual(legend_title, values = colors) +
    ggplot2::coord_fixed(clip = "off") +
    ggplot2::theme_void()
  p
}

# Legend ------------------------------------------------------------------

#' Create a plot legend
#'
#' @param labels Symbol labels. Enter as character vector (can include text to be parsed)
#' @param colors Symbol fill colors. Enter as character vector hexadecimal codes or color names. Length can be 1 or same length as `labels`
#' @param alpha Symbol fill transparency. Enter as length 1 numeric between 0-1. Default is `1`
#' @param shapes Symbol shapes. Enter as numeric or character vector of shapes. Length can be 1 or same length as `labels`
#' @param size Symbol size in inches. Enter as length 1 numeric. Default is `0.25`
#' @param border_thickness Symbol border thickness in pts. Enter as length 1 numeric. Set to `0` to remove symbol borders. Default is `1`
#' @param border_colors Symbol border colors. Enter as character vector hexadecimal codes or color names. Default is black
#' @param font_size Font size for symbol labels in pts. Enter as length 1 numeric. Default calculates font size from symbol size (`size`)
#' @param font_color Font color for symbol labels. Enter as length 1 character vector hexadecimal codes or color names. Default is black
#' @param font_face Font face for symbol labels.  Enter as length 1 character vector. Options: `"plain"` (default), `"italic"`, `"bold"`
#' @param labels_from_axis If `TRUE` (default), labels are derived from y axis text. If `FALSE`, labels are plotted using `geom_text`
#' @param nudge Horizontal space between symbol and label. Only relevant when `labels_from_axis = FALSE`. Enter as length 1 numeric. Default is `3.5`
#' @param parse If `TRUE`, symbol labels are generated by parsing input to `labels`. If `FALSE` (default), symbol labels appear exactly as specified in `labels`
#' @returns ggplot object
#' @noRd
manual_plot_legend <- function(
    labels,
    colors,
    alpha = 1,
    shapes = "square",
    size = 0.25,
    border_thickness = 1,
    border_colors = "#333333",
    font_size = NULL,
    font_color = "#333333",
    font_face = "plain",
    labels_from_axis = TRUE,
    nudge = 3.5,
    parse = FALSE) {
  if (is.character(shapes)) {
    look_up_point_shape <- c(circle = 21, square = 22, triangle = 24, diamond = 23)
    shapes <- look_up_point_shape[shapes]
    names(shapes) <- NULL
  }
  #font_size <- font_size %||% (79.5*size + 0.11)
  font_size <- font_size %||% (70*size)
  vert_gap <- size/0.6
  size <- 1/3*(100*size - 2)
  n <- length(labels)
  df <- vec_to_df(
    x = 0,
    fill = rep(colors, length.out = n),
    color = rep(border_colors, length.out = n),
    shape = rep(shapes, length.out = n)
  )

  if (labels_from_axis) {
    # Labels from axis text
    #df$y <- factor(labels, levels = rev(labels))
    #y_axis <- ggplot2::scale_y_discrete(position = "right")
    df$y <- breaks <- seq(1, by = vert_gap, length.out = n)
    y_axis <- ggplot2::scale_y_reverse(breaks = breaks, labels = labels, position = "right", expand = c(0, 5/n, 0, 5/n))
    text <- x_axis <- NULL
    axis.text.y.right <- ggplot2::element_text(size = font_size, color = font_color, face = font_face, vjust = 0.5, hjust = 0)
    aspect_ratio <- if (n > 5 && missing(nudge)) n else n*nudge
  } else {
    # Labels as plot component
    if (font_face != "plain") {
      labels <- sprintf("%s('%s')", font_face, labels)
      parse <- TRUE
    }
    df$y <- seq_len(n)
    df$label <- labels
    df$x_label <- nudge
    text <- ggplot2::geom_text(ggplot2::aes(x = x_label, label = label), size = font_size, size.unit = "pt", color = font_color, hjust = 0, vjust = 0.5, parse = parse)
    x_axis <- ggplot2::scale_x_continuous(limits = c(0, nudge*1.5))
    axis.text.y.right <- y_axis <- NULL
    aspect_ratio <- n
  }

  # Plot
  blank <- ggplot2::element_blank()
  ggplot2::ggplot(df, ggplot2::aes(x = x, y = y, fill = fill, color = color, shape = shape)) +
    ggplot2::geom_point(size = size, alpha = alpha, stroke = border_thickness) +
    text +
    ggplot2::scale_fill_identity() +
    ggplot2::scale_color_identity() +
    ggplot2::scale_shape_identity() +
    x_axis +
    y_axis +
    ggplot2::coord_cartesian(clip = "off") +
    ggplot2::theme(
      rect = blank,
      line = blank,
      axis.title = blank,
      axis.text = blank,
      axis.text.y.right = axis.text.y.right,
      legend.position = "none",
      aspect.ratio = aspect_ratio
    )
}

# Other -------------------------------------------------------------------

#' Convert static plot to interactive plot
#'
#' @param x ggplot object. Default is `last_plot()`
#' @param tooltip_vars Variables to display in tool tips. Enter as character vector
#' @param show_legend If `TRUE`, legend is displayed. If `FALSE` (default), no legend is displayed
#' @param dynamic_ticks If `TRUE` (default), dynamic ticks are shown. If `FALSE`, dynamic ticks are not shown
#' @returns plotly object
#' @noRd
plot_interactive <- function(x = last_plot(), tooltip_vars = NULL, show_legend = FALSE, dynamic_ticks = TRUE) {
  pkg_required("plotly")
  if (!is.null(tooltip_vars)) {
    x <- x + aes(text = .data[[tooltip_vars]])
  }
  if (!show_legend) {
    x <- x + theme(legend.position = "none")
  }
  tryCatch(suppress(plotly::ggplotly(x, dynamicTicks = dynamic_ticks)), error = function(e) suppress(plotly::ggplotly(x, dynamicTicks = FALSE)))
}

#' Alias for `plot_interactive`
#'
#' @param x ggplot object. Default is `last_plot()`
#' @param tooltip_vars Variables to display in tool tips. Enter as character vector
#' @param show_legend If `TRUE`, legend is displayed. If `FALSE` (default), no legend is displayed
#' @param dynamic_ticks If `TRUE` (default), dynamic ticks are shown. If `FALSE`, dynamic ticks are not shown
#' @returns plotly object
#' @noRd
plotly <- plot_interactive

#' Display ggproto function(s)
#'
#' @param x ggproto object (GeomX) or ggproto method (GeomX$setup_data)
#' @param fn Functions within `x` to return. Enter quoted or unquoted function names. If `NULL` (default), all functions returned
#' @param copy If `TRUE` (default) output is copied to clipboard
#' @returns Function or list of functions
#' @noRd
ggproto_fn <- function(x, fn = NULL, copy = TRUE) {
  x_name <- get_input(x)
  format_output <- function(z, fn_name) {
    if (is.function(z)) {
      args <- deparse(args(z), width.cutoff = 500L)
      args <- args[args != "NULL"]
      args <- sub("^[ \t\r\n]+", "", args, perl = TRUE)
      args <- paste0(args, collapse = "")
      body <- paste(deparse(body(z), width.cutoff = 500L), collapse = "\n")
      z <- paste0(args, body)
      z <- gsub("\\}\\s+else", "} else", z)
      z <- paste0(fn_name, " = ", z)
      z <- paste(z, collapse = "\n")
      z <- gsub("if\\(", "if (", z)
      z <- gsub("\\)\\{", ") {", z)
      z <- gsub("function \\(", "function(", z)
      z <- gsub(" \\* ", "*", z)
      z <- gsub("/", "/", z)
      paste0(z, collapse = "\n")
    } else if (inherits(z, "uneval")) {
      z <- vapply(unclass(z), function(x) paste(deparse(x, width.cutoff = 500L), collapse = " "), character(1))
      z <- paste(paste0(names(z), " = ", z), collapse = ",\n")
      paste0(fn_name, " = aes(\n", z, "\n)")
    } else {
      paste0(fn_name, " = ", paste(deparse(z, width.cutoff = 500L), collapse = " "))
    }
  }
  if (!inherits(x, "ggproto")) {
    if (inherits(x, "ggproto_method")) {
      x <- environment(x)$f
    }
    if (copy) {
      fn_string <- format_output(x, fn_name = if (is.character(x_name)) x_name else "fn")
      fn_string <- gsub("^fn = ", "", fn_string)
      tryNULL(suppress(copy(paste0(fn_string, "\n"))))
    }
    return(x)
  }
  x_list <- as.list(x)
  fn <- get_input(fn)
  x_names <- names(x_list)
  fn <- x_names[match(fn, x_names, nomatch = 0L)]
  n <- length(fn)
  out <- if (n == 0L) {
    fn <- x_names
    x_list
  } else if (n == 1L) {
    .subset2(x_list, fn)
  } else {
    .subset(x_list, fn)
  }
  if (copy) {
    fn_string <- if (n == 1L) {
      format_output(out, fn)
    } else {
      paste(vapply(seq_along(out), function(i) format_output(out[[i]], fn[i]), character(1), USE.NAMES = FALSE), collapse = "\n\n")
    }
    tryNULL(suppress(copy(paste0(fn_string, "\n"))))
  }
  out
}

